#!/usr/bin/ruby
require 'rubygems'
require 'net/ssh/multi'
require 'net/scp'

USAGE="Usage: #{$0} [options] [<script_to_execute>]"

pkg_utils=["htop"]

pkg_tmp_dependencies=[
	"cpufrequtils",
	"ethtool"
]

pkg_build=[
  "git",
  "debhelper",
  "gem2deb",
  "rubygems",
  "rake"
]
pkg_build_gem=[
  "rake-compiler"
]

PKG_NAME="distem"
DEB_REPOSITORY="http://distem.gforge.inria.fr/deb"
GIT_REPOSITORY="scm.gforge.inria.fr//gitroot//distem/distem.git"
HTTP_PROXY="http://proxy:3128/"
SSH_KEYS=["#{ENV['HOME']}/.ssh/id_dsa", "#{ENV['HOME']}/.ssh/id_rsa"]
PATH_DISTEMD_LOGS="/var/log/distem"
TMP_DIR="/tmp/distem"

options = {}
@options = options

def g5k?
  `hostname --fqdn`.chomp =~ /grid5000.fr$/
end


MSG_ERROR=0
MSG_WARNING=1
MSG_INFO=2

def msg(str, type=nil, quit=false)
  case type
  when MSG_ERROR
    puts("### Error: #{str} ###")
  when MSG_WARNING
    puts("### Warning: #{str} ###")
  when MSG_INFO
    puts(">>> #{str}")
  else
    puts str
  end
  exit 1 if quit
end

def open_channel(session, group = nil)
  if group.is_a?(Symbol)
    session.with(group).open_channel do |channel|
      yield(channel)
    end
  elsif group.is_a?(Array)
    session.on(*group).open_channel do |channel|
      yield(channel)
    end
  else
    session.open_channel do |channel|
      yield(channel)
    end
  end
end

def exec(session, cmd, group = nil, critical = false, showerr = true)
  outs = {}
  err = ""
  
  channel = open_channel(session,group) do |chtmp|
    chtmp.exec(cmd) do |ch, success|
      unless success
        msg("unable to execute '#{cmd}' on #{ch.connection.host}",MSG_ERROR)
      end
      msg("Executing '#{cmd}' on #{ch.connection.host}]",MSG_INFO) if @options[:debug]
    end
  end
  
  channel.on_data do |chtmp,data|
    outs[chtmp.connection.host] = [] unless outs[chtmp.connection.host]
    outs[chtmp.connection.host] << data.strip
    msg("[#{chtmp.connection.host}] #{data.strip}") if @options[:debug]
  end
  
  channel.on_extended_data do |chtmp,type,data|
    err = data.strip
  end
  
  channel.on_request("exit-status") do |chtmp, data|
    status = data.read_long
    if status != 0 and showerr
      msg("exec of '#{cmd}' on #{chtmp.connection.host} failed with return status #{status.to_s}",MSG_ERROR)
      msg("---stderr dump---\n#{err}\n---")
      exit 1 if critical
    end
  end
  
  channel.wait
  
  return outs
end


options[:init_pnodes] = false
options[:coordinator] = nil
options[:node_list] = nil
options[:packages] = []
options[:git] = nil
options[:ssh_key] = nil
options[:debug] = false
options[:version] = nil

optparse = OptionParser.new(USAGE) do |opts|
	opts.on( '-h', '--help', 'Display this screen' ) do
  		puts opts
  		exit
	end
	
	opts.on( '-i', '--init-pnodes [<coordinator_address>]', 'Launch the daemon' ) do |c|
  	options[:init_pnodes] = true
  	options[:coordinator] = c || nil
	end
	
	opts.on( '-n', '--node-list <nodelist_file>', 'Specify a file containing the list of the nodes to be installed' ) do |n|
  	options[:node_list] = n
	end
	
	opts.on( '-v', '--version <distem_version>', 'Specify the version of distem to be installed' ) do |v|
  	options[:version] = v
	end
	
	opts.on( '-d', '--debug', 'Verbose display of every instruction sent' ) do
  	options[:debug] = true
	end
	
	opts.on( '-k', '--ssh-key', 'Specify the path of the ssh private key to use' ) do |k|
  	options[:ssh_key] = k
	end
	
	opts.on( '-g', '--git <git_hash|git_tag>', 'Specify a specific version to install from git repository' ) do |n|
  	options[:git] = n
	end
	
	opts.on( '-p', '--packages <package1>,<package2>,<...>', Array, 'Specify additional packages to be installed' ) do |p|
  	options[:packages] = p
	end
end
optparse.parse!

nodelist = []

if options[:node_list]
	nodelist_file = options[:node_list]
elsif (ENV['GOOD_NODES'])
	nodelist_file = ENV['GOOD_NODES']
elsif (ENV['OAR_NODEFILE'])
	nodelist_file = ENV['OAR_NODEFILE']
else
  msg("nodelist parameter not set",MSG_ERROR,true)
end

begin
	File.open(nodelist_file, 'r') do |f|
	  f.each{ |line| nodelist << line.strip unless nodelist.include?(line.strip) }
	end
rescue Errno::ENOENT
	puts "File '#{nodelist_file}' not found"
	exit 1
end


if nodelist.empty?
  msg("nodelist parameter empty",MSG_ERROR,true)
end
nodelist.sort!


if options[:coordinator]
	coordinator = options[:coordinator]
else
	coordinator = nodelist[0]
end

if nodelist.include?(coordinator)
	nodelist.delete(coordinator)
else
	msg("Coordinator not present in <nodes_file>",MSG_WARNING)
end

if options[:ssh_key]
  if File.exists?(options[:ssh_key])
    sshkeyfile = options[:ssh_key]
  else
    msg("ssh key #{options[:ssh_key]} not found",MSG_ERR,true)
  end
else
  sshkeyfiles = SSH_KEYS.select { |keypath| File.exists?(keypath) }
  if sshkeyfiles.empty?
    msg("no ssh private key file found (specify one with -k)",MSG_ERROR,true)
  else
    sshkeyfile = sshkeyfiles[0]
  end
end
msg("Copying ssh private key file to the coordinator machine (#{coordinator})",MSG_INFO)
`scp #{sshkeyfile} root@#{coordinator}:/root/.ssh/`


if g5k? and `g5k-subnets`.strip.empty?
  msg('you did not make a subnet reservation (See g5k-subnets)',MSG_WARNING)
end

Net::SSH::Multi.start do |session|
  nodeobjlist = {}
	session.group :coord do 
    nodeobjlist[coordinator] = session.use("root@#{coordinator}")
  end
	session.group :nodes do
    nodelist.each{ |node| nodeobjlist[node] = session.use("root@#{node}") }
  end
  
	exec(session,"export http_proxy=#{HTTP_PROXY}")

  havesources = exec(session,"grep '#{DEB_REPOSITORY}' /etc/apt/sources.list",nil,false,false).keys
	needsources = (nodelist + [coordinator]) - havesources
	
	unless needsources.empty?
    needsources.collect!{ |node| nodeobjlist[node] }
    exec(session,"echo 'deb #{DEB_REPOSITORY} ./' >> /etc/apt/sources.list", needsources)
    session.loop
  end

  msg("Updating debian packages list",MSG_INFO)
  exec(session,'apt-get update -q')
  
  if options[:git]
    msg("Installing debian build packages on #{coordinator}",MSG_INFO)
    exec(session,"apt-get install -q -y #{pkg_build.join(' ')}",:coord,true)
    msg("Installing gems build packages on #{coordinator}",MSG_INFO)
    exec(session,"export http_proxy=#{HTTP_PROXY}; gem install #{pkg_build_gem.join(' ')}",:coord,true)
    exec(session,"rm -Rf #{TMP_DIR}")
    exec(session,"mkdir -p #{TMP_DIR}")
    gitdir = "#{TMP_DIR}/git"
    exec(session,"rm -Rf #{gitdir}",:coord)
    msg("Retriving git repository on #{coordinator}",MSG_INFO)
    exec(session,"yes | head -n1 | git clone git+ssh://olbat@#{GIT_REPOSITORY} #{gitdir}",:coord,true)
    msg("Setting up git repository ref:#{options[:git]} on #{coordinator}",MSG_INFO)
    exec(session,"git --git-dir=#{gitdir}/.git reset --hard #{options[:git]}",:coord,true)
    msg("Building debian package of distem on #{coordinator}",MSG_INFO)
    exec(session,"rake -f #{gitdir}/Rakefile snapshot",:coord)
    msg("Copying generated debian package of distem",MSG_INFO)
    #>>> FIXME: Change this directory by the path to the debian archive
    debarchivefile = "#{gitdir}/debian/copyright"
    exec(session,"cp #{debarchivefile} #{TMP_DIR}",:coord,true)
    nodelist.each {|node| exec(session,"scp #{debarchivefile} root@#{node}:#{TMP_DIR}",:coord,true)}
    exec(session,"dpkg -i #{TMP_DIR}/#{File.basename(debarchivefile)}",nil,true)
    exec(session,"apt-get build-dep distem",nil,true)
    exec(session,"apt-get install -f")
  else
    msg("Installing debian distem packages",MSG_INFO)
    distempkg = (options[:version] ? "#{PKG_NAME}=#{options[:version]}" : PKG_NAME)
    exec(session,"yes | head -n1 | apt-get install -q -y --force-yes --allow-unauthenticated #{distempkg}",nil,true)
	end
	
	msg("Installing debian misc packages",MSG_INFO)
  exec(session,"apt-get install -q -y #{pkg_tmp_dependencies.join(' ')}")
  exec(session,"apt-get install -q -y #{pkg_utils.join(' ')}")
  options[:packages].each do |pkg|
    msg("Installing additional debian package '#{pkg}'",MSG_INFO)
    exec(session,"apt-get install -q -y #{pkg}")
  end
  
  session.loop
	
	if options[:init_pnodes]
	  msg("Running coordinator daemon on #{nodelist[0]}",MSG_INFO)
	  tokill = exec(session,"lsof -Pnl -i4 | grep '^distemd.*$'",nil,false,false).keys
	  unless tokill.empty?
	    tokill.collect!{ |node| nodeobjlist[node] }
	    exec(session,"killall distemd",tokill)
	    session.loop
	    #sleep(1)
	  end
	  exec(session,"mkdir -p #{PATH_DISTEMD_LOGS}",:coord)
	  exec(session,"distemd -d 1>#{File.join(PATH_DISTEMD_LOGS,'distemd.out')} &>#{File.join(PATH_DISTEMD_LOGS,'distemd.err')} &",:coord,true)
	  sleep(2)
	  nodelist.each do |node|
	    exec(session,"distem -d #{coordinator} -i #{node}",:coord,true)
    end
	end
	
	str = "Install done"
  str += ", coordinator: #{coordinator}" if options[:init_pnodes]
  msg(str)
	
	if ARGV[0]
	  msg("Executing script file",MSG_INFO)
	  begin
		  File.open(ARGV[0], 'r') do |f|
		    filename = "/root/#{File.basename(ARGV[0])}"
		    exec(session,"echo '#{f.read}' > #{filename}",:coord)
		    exec(session,"chmod +x #{filename}",:coord)
		    exec(session,filename,:coord)
		  end
		  msg("Script execution done",MSG_INFO)
	  rescue Errno::ENOENT
      msg("script file '#{ARGV[0]}' not found",MSG_ERROR,true)
    end
	end
end
