#!/usr/bin/ruby
require 'rubygems'
require 'net/ssh/multi'
require 'net/scp'

USAGE="Usage: #{$0} [options] [<script_to_execute>]"

pkg_utils=["htop"]

pkg_tmp_dependencies=[
	"cpufrequtils",
	"ethtool"
]

pkg_build=[
  "git",
  "rake"
]
pkg_build_gem=[
  #"rake-compiler"
]

PKG_NAME="distem"
DEB_REPOSITORY="http://distem.gforge.inria.fr/deb"
GIT_REPOSITORY="http://public.nancy.grid5000.fr/~lsarzyniec/distem.git"
HTTP_PROXY="http://proxy:3128/"
SSH_KEYS=["#{ENV['HOME']}/.ssh/id_dsa", "#{ENV['HOME']}/.ssh/id_rsa"]
PATH_DISTEMD_LOGS="/var/log/distem"
TMP_DIR="/tmp/distem"

options = {}
@options = options

def g5k?
  `hostname --fqdn`.chomp =~ /grid5000.fr$/
end


MSG_ERROR=0
MSG_WARNING=1
MSG_INFO=2

def msg(str, type=nil, quit=false)
  case type
  when MSG_ERROR
    puts("### Error: #{str} ###")
  when MSG_WARNING
    puts("### Warning: #{str} ###")
  when MSG_INFO
    puts(">>> #{str}")
  else
    puts str
  end
  exit 1 if quit
end

def open_channel(session, group = nil)
  if group.is_a?(Symbol)
    session.with(group).open_channel do |channel|
      yield(channel)
    end
  elsif group.is_a?(Array)
    session.on(*group).open_channel do |channel|
      yield(channel)
    end
  else
    session.open_channel do |channel|
      yield(channel)
    end
  end
end

def exec(session, cmd, group = nil, critical = false, showerr = true, showout = false)
  outs = {}
  errs = {}
  
  channel = open_channel(session,group) do |chtmp|
    chtmp.exec(cmd) do |ch, success|
      unless success
        msg("unable to execute '#{cmd}' on #{ch.connection.host}",MSG_ERROR)
      end
      msg("Executing '#{cmd}' on #{ch.connection.host}]",MSG_INFO) if @options[:debug]
    end
  end
  
  channel.on_data do |chtmp,data|
    outs[chtmp.connection.host] = [] unless outs[chtmp.connection.host]
    outs[chtmp.connection.host] << data.strip
    msg("[#{chtmp.connection.host}] #{data.strip}") if @options[:debug] or showout
  end
  
  channel.on_extended_data do |chtmp,type,data|
    errs[chtmp.connection.host] = [] unless errs[chtmp.connection.host]
    errs[chtmp.connection.host] << data.strip
  end
  
  channel.on_request("exit-status") do |chtmp, data|
    status = data.read_long
    if status != 0 and showerr
      msg("exec of '#{cmd}' on #{chtmp.connection.host} failed with return status #{status.to_s}",MSG_ERROR)
      msg("---stdout dump---")
      outs[chtmp.connection.host].each { |out| msg(out) } if outs[chtmp.connection.host]
      msg("---stderr dump---")
      errs[chtmp.connection.host].each { |err| msg(err) } if errs[chtmp.connection.host]
      msg("---\n")
      exit 1 if critical
    end
  end
  
  channel.wait
  
  return outs
end


options[:init_pnodes] = false
options[:coordinator] = nil
options[:node_list] = nil
options[:packages] = []
options[:git] = nil
options[:ssh_key] = nil
options[:debug] = false
options[:version] = nil

optparse = OptionParser.new(USAGE) do |opts|
	opts.on( '-h', '--help', 'Display this screen' ) do
  		puts opts
  		exit
	end
	
	opts.on( '-i', '--init-pnodes [<coordinator_address>]', 'Launch the daemon' ) do |c|
  	options[:init_pnodes] = true
  	options[:coordinator] = c || nil
	end
	
	opts.on( '-n', '--node-list <nodelist_file>', 'Specify a file containing the list of the nodes to be installed' ) do |n|
  	options[:node_list] = n
	end
	
	opts.on( '-v', '--version <distem_version>', 'Specify the version of distem to be installed' ) do |v|
  	options[:version] = v
	end
	
	opts.on( '-d', '--debug', 'Verbose display of every instruction sent' ) do
  	options[:debug] = true
	end
	
	opts.on( '-k', '--ssh-key', 'Specify the path of the ssh private key to use' ) do |k|
  	options[:ssh_key] = k
	end
	
	opts.on( '-g', '--git [<git_hash|git_tag>]', "Specify a specific version to install from git repository (if not specified, taking the last revision). Some packages are installed on one of the nodes in order to build the debian package (See `apt-get build-dep distem` + deb: #{pkg_build.join(",")} + gem: #{pkg_build_gem.join(",")})" ) do |n|
  	options[:git] = n || :git_last
	end
	
	opts.on( '-p', '--packages <package1>,<package2>,<...>', Array, 'Specify additional packages to be installed' ) do |p|
  	options[:packages] = p
	end
end
optparse.parse!

nodelist = []

if options[:node_list]
	nodelist_file = options[:node_list]
elsif (ENV['GOOD_NODES'])
	nodelist_file = ENV['GOOD_NODES']
elsif (ENV['OAR_NODEFILE'])
	nodelist_file = ENV['OAR_NODEFILE']
else
  msg("nodelist parameter not set",MSG_ERROR,true)
end

begin
	File.open(nodelist_file, 'r') do |f|
	  f.each{ |line| nodelist << line.strip unless nodelist.include?(line.strip) }
	end
rescue Errno::ENOENT
	puts "File '#{nodelist_file}' not found"
	exit 1
end


if nodelist.empty?
  msg("nodelist parameter empty",MSG_ERROR,true)
end
nodelist.sort!

if options[:coordinator]
	coordinator = options[:coordinator]
else
	coordinator = nodelist[0]
end

if nodelist.include?(coordinator)
	nodelist.delete(coordinator)
else
	msg("Coordinator not present in <nodes_file>",MSG_WARNING)
end

if options[:ssh_key]
  if File.exists?(options[:ssh_key])
    sshkeyfile = options[:ssh_key]
  else
    msg("ssh key #{options[:ssh_key]} not found",MSG_ERR,true)
  end
else
  sshkeyfiles = SSH_KEYS.select { |keypath| File.exists?(keypath) }
  if sshkeyfiles.empty?
    msg("no ssh private key file found (specify one with -k)",MSG_ERROR,true)
  else
    sshkeyfile = sshkeyfiles[0]
  end
end
msg("Copying ssh private key file to the coordinator machine (#{coordinator})",MSG_INFO)
`scp #{sshkeyfile} root@#{coordinator}:/root/.ssh/`


if g5k? and `g5k-subnets`.strip.empty?
  msg('you did not make a subnet reservation (See g5k-subnets)',MSG_WARNING)
end

Net::SSH::Multi.start do |session|
  nodeobjlist = {}
	session.group :coord do 
    nodeobjlist[coordinator] = session.use("root@#{coordinator}")
  end
	session.group :nodes do
    nodelist.each{ |node| nodeobjlist[node] = session.use("root@#{node}") }
  end
  
  havesources = exec(session,"grep '#{DEB_REPOSITORY}' /etc/apt/sources.list",nil,false,false).keys
	needsources = (nodelist + [coordinator]) - havesources
	
	unless needsources.empty?
    needsources.collect!{ |node| nodeobjlist[node] }
    exec(session,"echo 'deb #{DEB_REPOSITORY} ./\ndeb-src #{DEB_REPOSITORY} ./' >> /etc/apt/sources.list", needsources)
    session.loop
  end

  msg("Updating debian packages list",MSG_INFO)
  exec(session,'apt-get update -q')
  
  if options[:git]
=begin
    keycheck = exec(session,"grep StrictHostKeyChecking /root/.ssh/config",:coord)
    if keycheck.empty?
      msg("Disabling SSH StrictHostKeyChecking config on #{coordinator}",MSG_INFO)
      exec(session,"echo 'Host *\nStrictHostKeyChecking no' >> /root/.ssh/config",:coord)
    end
=end
    msg("Installing debian build packages on #{coordinator}",MSG_INFO)
    exec(session,"apt-get build-dep -y --force-yes distem",:coord,true)
    exec(session,"apt-get install -q -y --force-yes #{pkg_build.join(' ')}",:coord,true) unless pkg_build.empty?
    unless pkg_build_gem.empty?
      msg("Installing gems build packages on #{coordinator}",MSG_INFO)
      exec(session,"export http_proxy=#{HTTP_PROXY}; gem install #{pkg_build_gem.join(' ')}",:coord,true)
    end
    gitdir = "#{TMP_DIR}/git"
    exec(session,"mkdir -p #{TMP_DIR}")
    exec(session,"rm -Rf #{gitdir}",:coord)
    msg("Retriving '#{GIT_REPOSITORY}' repository on #{coordinator}",MSG_INFO)
    exec(session,"git clone #{GIT_REPOSITORY} #{gitdir}",:coord,true)
    unless options[:git] == :git_last
      msg("Setting up git repository ref:#{options[:git]} on #{coordinator}",MSG_INFO)
      exec(session,"git --git-dir=#{gitdir}/.git reset --hard #{options[:git]}",:coord,true)
    end
    msg("Building debian package of distem on #{coordinator}",MSG_INFO)
    exec(session,"rm -f #{TMP_DIR}/*.deb #{TMP_DIR}/*.changes #{TMP_DIR}/*.dsc #{TMP_DIR}/*.tar.gz",:coord)
    exec(session,"cd #{gitdir}; rake snapshot",:coord,true)
    
    debarchivefile = exec(session,"find #{TMP_DIR} -name *.deb",:coord)[coordinator][0]
    msg("Copying generated debian package #{File.basename(debarchivefile)}",MSG_INFO)
    #exec(session,"cp #{debarchivefile} #{TMP_DIR}",:coord,true)
    nodelist.each {|node| exec(session,"scp #{debarchivefile} root@#{node}:#{TMP_DIR}",:coord,true)}
    msg("Installing generated debian package #{File.basename(debarchivefile)}",MSG_INFO)
    depends = exec(session,"dpkg -I #{debarchivefile} | grep 'Depends:'",:coord)[coordinator][0]
    depends = depends.split("|").last.gsub!(' ','')
    exec(session,"dpkg --ignore-depends #{depends} -i #{TMP_DIR}/#{File.basename(debarchivefile)}",nil,false,false)
    exec(session,"apt-get install -f -y --force-yes",nil,true)
    msg("Cleaning installation files on #{coordinator}",MSG_INFO)
    exec(session,"rm -Rf #{gitdir}",:coord)
    exec(session,"rm -f #{TMP_DIR}/*.deb #{TMP_DIR}/*.changes #{TMP_DIR}/*.dsc #{TMP_DIR}/*.tar.gz",:coord)
  else
    msg("Installing debian distem packages",MSG_INFO)
    distempkg = (options[:version] ? "#{PKG_NAME}=#{options[:version]}" : PKG_NAME)
    exec(session,"apt-get install -q -y --force-yes --allow-unauthenticated #{distempkg}",nil,true)
	end
	
	msg("Installing debian misc packages",MSG_INFO)
  exec(session,"apt-get install -q -y --force-yes #{pkg_tmp_dependencies.join(' ')}") unless pkg_tmp_dependencies.empty?
  exec(session,"apt-get install -q -y --force-yes #{pkg_utils.join(' ')}") unless pkg_utils.empty?
  options[:packages].each do |pkg|
    msg("Installing additional debian package '#{pkg}'",MSG_INFO)
    exec(session,"apt-get install -q -y --force-yes #{pkg}")
  end
  
  session.loop
	
	if options[:init_pnodes]
	  launched = exec(session,"lsof -Pnl -i4 | grep '^distemd.*$'",nil,false,false)
	  unless launched.empty?
	    tokill = launched.keys
	    tokill.collect!{ |node| nodeobjlist[node] }
	    tokill.each { |node| msg("Killed previous run of distem on #{node}",MSG_INFO) }
	    exec(session,"killall distemd",tokill,false,false)
	    until launched.empty?
	      launched = exec(session,"lsof -Pnl -i4 | grep '^distemd.*$'",tokill,false,false)
	      if launched and !launched.empty?
	        tokill = launched.keys
	        tokill.collect!{ |node| nodeobjlist[node] }
	      end
	    end
	    session.loop
	  end
	  msg("Running coordinator daemon on #{coordinator}",MSG_INFO)
	  exec(session,"mkdir -p #{PATH_DISTEMD_LOGS}",:coord)
	  exec(session,"distemd -d &>#{File.join(PATH_DISTEMD_LOGS,'distemd.log')} &",:coord,true)
	  
	  launched = []
	  while launched and launched.empty?
	    launched = exec(session,"lsof -Pnl -i4 | grep '^distemd.*$'",:coord,false,false)[coordinator]
      sleep(0.1)
    end
    msg("Coordinator daemon launched on #{coordinator}",MSG_INFO)
    session.loop
	  exec(session,"distem -d #{coordinator} -i #{coordinator}",:coord,true)
	  nodelist.each do |node|
	    msg("Initializing node #{node}",MSG_INFO)
	    exec(session,"distem -d #{coordinator} -i #{node}",:coord,true,false,true)
    end
	end
	
	str = "Install done"
  str += ", coordinator: #{coordinator}" if options[:init_pnodes]
  msg(str)
	
	if ARGV[0]
	  msg("Executing script file",MSG_INFO)
	  begin
		  File.open(ARGV[0], 'r') do |f|
		    filename = "/root/#{File.basename(ARGV[0])}"
		    exec(session,"echo '#{f.read}' > #{filename}",:coord)
		    exec(session,"chmod +x #{filename}",:coord)
		    exec(session,filename,:coord)
		  end
		  msg("Script execution done",MSG_INFO)
	  rescue Errno::ENOENT
      msg("script file '#{ARGV[0]}' not found",MSG_ERROR,true)
    end
	end
end
