#!/usr/bin/ruby
require 'rubygems'
require 'net/ssh/multi'
require 'net/scp'


pkg_utils=[
  "htop"
]

pkg_tmp_dependencies=[
	"cpufrequtils",
	"ethtool"
]

pkg_build=[
  "git",
  "rake"
]

pkg_build_gem=[
  #"rake-compiler"
]

PKG_NAME="distem"
DEB_REPOSITORY="http://distem.gforge.inria.fr/deb"
HTTP_PROXY="http://proxy:3128/"
SSH_KEYS=["#{ENV['HOME']}/.ssh/id_dsa", "#{ENV['HOME']}/.ssh/id_rsa"]
PATH_DISTEMD_LOGS="/var/log/distem"
TMP_DIR="/tmp/distem"
VAR_DISTEM_NODES="DISTEM_NODES"
VAR_DISTEM_COORD="DISTEM_COORDINATOR"

def g5k?
  `hostname --fqdn`.chomp =~ /grid5000.fr$/
end

if g5k?
  GIT_REPOSITORY="git://beaujolais.nancy.grid5000.fr/distem/distem.git"
else
  GIT_REPOSITORY="git://scm.gforge.inria.fr/distem/distem.git"
end

USAGE="Usage: #{$0} [options] [<script_to_execute>]\nWhen executing a script file nodelist is available in the env var #{VAR_DISTEM_NODES}, the coordinator in #{VAR_DISTEM_COORD}."

options = {}
@options = options

MSG_ERROR=0
MSG_WARNING=1
MSG_INFO=2

def msg(str, type=nil, quit=false)
  case type
  when MSG_ERROR
    puts("### Error: #{str} ###")
  when MSG_WARNING
    puts("### Warning: #{str} ###")
  when MSG_INFO
    puts(">>> #{str}")
  else
    puts str
  end
  exit 1 if quit
end

def open_channel(session, group = nil)
  if group.is_a?(Symbol)
    session.with(group).open_channel do |channel|
      yield(channel)
    end
  elsif group.is_a?(Array)
    session.on(*group).open_channel do |channel|
      yield(channel)
    end
  elsif group.is_a?(Net::SSH::Multi::Server)
    session.on(group).open_channel do |channel|
      yield(channel)
    end
  else
    session.open_channel do |channel|
      yield(channel)
    end
  end
end

def exec(session, cmd, group = nil, critical = false, showerr = true, showout = false)
  outs = {}
  errs = {}
  
  channel = open_channel(session,group) do |chtmp|
    chtmp.exec(cmd) do |ch, success|
      unless success
        msg("unable to execute '#{cmd}' on #{ch.connection.host}",MSG_ERROR)
      end
      msg("Executing '#{cmd}' on #{ch.connection.host}]",MSG_INFO) if @options[:debug]
    end
  end
  
  channel.on_data do |chtmp,data|
    outs[chtmp.connection.host] = [] unless outs[chtmp.connection.host]
    outs[chtmp.connection.host] << data.strip
    msg("[#{chtmp.connection.host}] #{data.strip}") if @options[:debug] or showout
  end
  
  channel.on_extended_data do |chtmp,type,data|
    errs[chtmp.connection.host] = [] unless errs[chtmp.connection.host]
    errs[chtmp.connection.host] << data.strip
  end
  
  channel.on_request("exit-status") do |chtmp, data|
    status = data.read_long
    if status != 0 and showerr
      msg("exec of '#{cmd}' on #{chtmp.connection.host} failed with return status #{status.to_s}",MSG_ERROR)
      msg("---stdout dump---")
      outs[chtmp.connection.host].each { |out| msg(out) } if outs[chtmp.connection.host]
      msg("---stderr dump---")
      errs[chtmp.connection.host].each { |err| msg(err) } if errs[chtmp.connection.host]
      msg("---\n")
      exit 1 if critical
    end
  end
  
  channel.wait
  
  return outs
end


options[:init_pnodes] = false
options[:coordinator] = nil
options[:node_list] = nil
options[:debpackages] = []
options[:gempackages] = []
options[:git] = nil
options[:ssh_key] = nil
options[:debug] = false
options[:version] = nil
options[:debug_distem] = false


optparse = OptionParser.new(USAGE) do |opts|
	opts.on( '-h', '--help', 'Display this screen' ) do
  		puts opts
  		exit
	end
	
	opts.on( '-i', '--init-pnodes [<coordinator_address>]', 'Launch the daemon' ) do |c|
  	options[:init_pnodes] = true
  	options[:coordinator] = c || nil
	end
	
	opts.on( '-n', '--node-list <nodelist_file>', 'Specify a file containing the list of the nodes to be installed' ) do |n|
  	options[:node_list] = n
	end
	
	opts.on( '-v', '--version <distem_version>', 'Specify the version of distem to be installed' ) do |v|
  	options[:version] = v
	end
	
	opts.on( '-d', '--debug', 'Verbose display of every instruction sent' ) do
  	options[:debug] = true
	end
	
	opts.on( '-k', '--ssh-key', 'Specify the path of the ssh private key to use' ) do |k|
  	options[:ssh_key] = k
	end
	
	opts.on( '-g', '--git [<git_hash|git_tag>]', "Specify a specific version to install from git repository (if not specified, taking the last revision). Some packages are installed on one of the nodes in order to build the debian package (See `apt-get build-dep distem` + deb: #{pkg_build * ","} + gem: #{pkg_build_gem * ","})" ) do |n|
  	options[:git] = n || :git_last
	end
	
	opts.on( '-p', '--debpackages <package1>,<package2>,<...>', Array, 'Specify additional debian packages to be installed' ) do |p|
  	options[:debpackages] = p
	end
	
	opts.on( '-r', '--gempackages <package1>,<package2>,<...>', Array, 'Specify additional gem packages to be installed' ) do |p|
  	options[:gempackages] = p
	end
	
	opts.on( '-s', '--distem-debug', Array, 'Show distem output when executing distem commands (script, node init)' ) do
  	options[:debug_distem] = true
	end
end
optparse.parse!

nodelist = []

if options[:node_list]
	nodelist_file = options[:node_list]
elsif (ENV['GOOD_NODES'])
	nodelist_file = ENV['GOOD_NODES']
elsif (ENV['OAR_NODEFILE'])
	nodelist_file = ENV['OAR_NODEFILE']
else
  msg("nodelist parameter not set",MSG_ERROR,true)
end

begin
	File.open(nodelist_file, 'r') do |f|
	  f.each{ |line| nodelist << line.strip unless nodelist.include?(line.strip) }
	end
rescue Errno::ENOENT
	puts "File '#{nodelist_file}' not found"
	exit 1
end


if nodelist.empty?
  msg("nodelist parameter empty",MSG_ERROR,true)
end
nodelist.sort!

if options[:coordinator]
	coordinator = options[:coordinator]
else
	coordinator = nodelist[0]
end

if nodelist.include?(coordinator)
	nodelist.delete(coordinator)
else
	msg("Coordinator not present in <nodes_file>",MSG_WARNING)
end

if g5k? and `g5k-subnets`.strip.empty?
  msg('you did not make a subnet reservation (See g5k-subnets)',MSG_WARNING)
end

if options[:ssh_key]
  if File.exists?(options[:ssh_key])
    sshkeyfile = options[:ssh_key]
  else
    msg("ssh key #{options[:ssh_key]} not found",MSG_ERR,true)
  end
else
  sshkeyfiles = SSH_KEYS.select { |keypath| File.exists?(keypath) }
  if sshkeyfiles.empty?
    msg("no ssh private key file found (specify one with -k)",MSG_ERROR,true)
  else
    sshkeyfile = sshkeyfiles[0]
  end
end
msg("Copying ssh private key file to the coordinator machine (#{coordinator})",MSG_INFO)
`scp #{sshkeyfile} root@#{coordinator}:/root/.ssh/`


Net::SSH::Multi.start do |session|
  nodeobjlist = {}
  begin
	  session.group :coord do 
        nodeobjlist[coordinator] = session.use("root@#{coordinator}")
    end
    #test the connection
    exec(session,"hostname",:coord)
    msg("Connection with #{coordinator} established",MSG_INFO)
  rescue SocketError
    msg("can't connect to #{coordinator}",MSG_ERROR,true)
  end
  
	session.group :nodes do
    nodelist.each do |node|
      begin
        nodeobjlist[node] = session.use("root@#{node}")
        #test the connection
        exec(session,"hostname",nodeobjlist[node])
        msg("Connection with #{node} established",MSG_INFO)
      rescue SocketError
        msg("can't connect to #{node}",MSG_ERROR,true)
      end
    end
  end
  
  
  havesources = exec(session,"grep '#{DEB_REPOSITORY}' /etc/apt/sources.list",nil,false,false).keys
	needsources = (nodelist + [coordinator]) - havesources
	
	unless needsources.empty?
    needsources.collect!{ |node| nodeobjlist[node] }
    exec(session,"echo 'deb #{DEB_REPOSITORY} ./\ndeb-src #{DEB_REPOSITORY} ./' >> /etc/apt/sources.list", needsources)
    session.loop
  end

  msg("Updating debian packages list",MSG_INFO)
  exec(session,'apt-get update -q')
  
  if options[:git]
=begin
    keycheck = exec(session,"grep StrictHostKeyChecking /root/.ssh/config",:coord)
    if keycheck.empty?
      msg("Disabling SSH StrictHostKeyChecking config on #{coordinator}",MSG_INFO)
      exec(session,"echo 'Host *\nStrictHostKeyChecking no' >> /root/.ssh/config",:coord)
    end
=end
    msg("Installing debian build packages on #{coordinator}",MSG_INFO)
    exec(session,"apt-get build-dep -y --force-yes distem",:coord,true)
    exec(session,"apt-get install -q -y --force-yes #{pkg_build * ' '}",:coord,true) unless pkg_build.empty?
    unless pkg_build_gem.empty?
      msg("Installing gems build packages on #{coordinator}",MSG_INFO)
      exec(session,"export http_proxy=#{HTTP_PROXY}; gem install #{pkg_build_gem * ' '}",:coord,true)
    end
    gitdir = "#{TMP_DIR}/git"
    exec(session,"mkdir -p #{TMP_DIR}")
    exec(session,"rm -Rf #{gitdir}",:coord)
    msg("Retrieving '#{GIT_REPOSITORY}' repository on #{coordinator}",MSG_INFO)
    exec(session,"git clone #{GIT_REPOSITORY} #{gitdir}",:coord,true)
    unless options[:git] == :git_last
      msg("Setting up git repository ref:#{options[:git]} on #{coordinator}",MSG_INFO)
      exec(session,"git --git-dir=#{gitdir}/.git reset --hard #{options[:git]}",:coord,true)
    end
    msg("Building debian package of distem on #{coordinator}",MSG_INFO)
    exec(session,"rm -f #{TMP_DIR}/*.deb #{TMP_DIR}/*.changes #{TMP_DIR}/*.dsc #{TMP_DIR}/*.tar.gz",:coord)
    exec(session,"cd #{gitdir}; rake snapshot",:coord,true)
    
    debarchivefile = exec(session,"find #{TMP_DIR} -maxdepth 1 -name *.deb",:coord)[coordinator][0]
    msg("Copying generated debian package #{File.basename(debarchivefile)}",MSG_INFO)
    #exec(session,"cp #{debarchivefile} #{TMP_DIR}",:coord,true)
    nodelist.each {|node| exec(session,"scp -o StrictHostKeyChecking=no #{debarchivefile} root@#{node}:#{TMP_DIR}",:coord,true)}
    msg("Installing generated debian package #{File.basename(debarchivefile)}",MSG_INFO)
    depends = exec(session,"dpkg -I #{debarchivefile} | grep 'Depends:'",:coord)[coordinator][0]
    depends = depends.split("|").last.gsub!(' ','')
    exec(session,"dpkg --ignore-depends #{depends} -i #{TMP_DIR}/#{File.basename(debarchivefile)}",nil,true)
    exec(session,"echo yes | apt-get install -q -y --force-yes -f",nil,true)
    msg("Cleaning installation files on #{coordinator}",MSG_INFO)
    #exec(session,"rm -Rf #{gitdir}",:coord)
    #exec(session,"rm -f #{TMP_DIR}/*.deb #{TMP_DIR}/*.changes #{TMP_DIR}/*.dsc #{TMP_DIR}/*.tar.gz",:coord)
  else
    msg("Installing debian distem packages",MSG_INFO)
    distempkg = (options[:version] ? "#{PKG_NAME}=#{options[:version]}" : PKG_NAME)
    exec(session,"echo yes | apt-get install -q -y --force-yes --allow-unauthenticated #{distempkg}",nil,true)
	end
	
	msg("Installing debian misc packages",MSG_INFO)
  exec(session,"apt-get install -q -y --force-yes #{pkg_tmp_dependencies * ' '}") unless pkg_tmp_dependencies.empty?
  exec(session,"apt-get install -q -y --force-yes #{pkg_utils * ' '}") unless pkg_utils.empty?
  options[:debpackages].each do |debpkg|
    msg("Installing additional debian package '#{debpkg}'",MSG_INFO)
    exec(session,"apt-get install -q -y --force-yes #{debpkg}",true)
  end
  options[:gempackages].each do |gempkg|
    msg("Installing additional gem package '#{gempkg}'",MSG_INFO)
    exec(session,"export http_proxy=#{HTTP_PROXY}; gem install #{gempkg}",:coord,true)
  end
  
  session.loop
	
	if options[:init_pnodes]
	  launched = exec(session,"lsof -Pnl -i4 | grep '^distemd.*$'",nil,false,false)
	  unless launched.empty?
	    tokill = launched.keys
	    tokill.collect!{ |node| nodeobjlist[node] }
	    tokill.each { |node| msg("Killing previous run of distem on #{node}",MSG_INFO) }
	    exec(session,"killall distemd",tokill,false,false)
	    time_start = Time.now
	    until !launched or launched.empty?
	      exec(session,"killall -9 distemd",tokill,false,false) if (Time.now - time_start) > 2
	      launched = exec(session,"lsof -Pnl -i4 | grep '^distemd.*$'",tokill,false,false)
	      if launched and !launched.empty?
	        tokill = launched.keys
	        tokill.collect!{ |node| nodeobjlist[node] }
	      end
	    end
	    session.loop
	  end
	  msg("Starting coordinator daemon on #{coordinator}",MSG_INFO)
	  exec(session,"mkdir -p #{PATH_DISTEMD_LOGS}",:coord)
	  exec(session,"distemd -d &>#{File.join(PATH_DISTEMD_LOGS,'distemd.log')} &",:coord,true)
	  
	  launched = []
	  until launched and !launched.empty?
	    launched = exec(session,"lsof -Pnl -i4 | grep '^distemd.*$'",:coord,false,false)[coordinator]
      sleep(0.1)
    end
    session.loop
    
    msg("Initializing node #{coordinator}",MSG_INFO)
	  exec(session,"distem -d #{coordinator} -i #{coordinator}",:coord,true)
	  nodelist.each do |node|
	    msg("Initializing node #{node}",MSG_INFO)
	    exec(session,"distem -d #{coordinator} -i #{node}",:coord,true,options[:debug_distem],options[:debug_distem])
    end
	end
	
	str = "Install done"
  str += ", coordinator: #{coordinator}" if options[:init_pnodes]
  msg(str)
	
	if ARGV[0]
	  begin
		  File.open(ARGV[0], 'r') do |f|
		    filename = "/root/#{File.basename(ARGV[0])}"
		    msg("Copying script file in '#{filename}' on #{coordinator}",MSG_INFO)
		    exec(session,"cat <<EOF > #{filename} \n#{f.read}\nEOF",:coord)
		    exec(session,"chmod +x #{filename}",:coord)
		    msg("Executing script file '#{File.basename(filename)}' on #{coordinator}",MSG_INFO)
		    
		    exec(session,"export #{VAR_DISTEM_NODES}='#{(nodelist + [coordinator]) * "\n"}'; export #{VAR_DISTEM_COORD}='#{coordinator}';#{filename}",:coord,true,options[:debug_distem],options[:debug_distem])
		  end
		  msg("Script execution done")
	  rescue Errno::ENOENT
      msg("script file '#{ARGV[0]}' not found",MSG_ERROR,true)
    end
	end
end
